{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MPU-6500 and MPU-9250 Driver for TI-RTOS","text":"<p>A comprehensive, easy-to-use I2C driver for the MPU-6500 and the MPU-9250 IMU, specifically tailored for the TI-RTOS environment on the MSP-EXP432E401Y platform. This library offers multiple levels of abstraction to get you up and running quickly.</p> <p>This library provides everything you need to go from raw sensor readings to a fully calibrated, high-performance orientation solution.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multi-Level API: Choose the abstraction level that fits your needs:</li> <li>A C library for direct register access, raw data and a complete sensor fusion hub.</li> <li>A high-level C++ class that encapsulates the complex InvenSense DMP.</li> <li>A C-compatible wrapper for using the DMP from any C project.</li> <li>Sensor Fusion Options: Includes a full implementation of the onboard Digital Motion Processor (DMP) for 6-axis quaternion output. The low-level C library includes options for simple Complementary Filter as well as advanced  Madgwick and Mahony Filters for either 6-axis or 9-axis quaternion output, with the possibility to convert to Euler Angles directly.</li> <li>TI-RTOS Integration: Designed from the ground up for a real-time, task-based environment, using TI Drivers for I2C and TI-RTOS primitives for timing.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The core DMP driver is based on the work by InvenSense/TDK.</p> <p>The C++ wrapper is an adaptation of the excellent SparkFun MPU-9250 DMP Arduino Library.</p>"},{"location":"api/c_driver/","title":"MPU9250 9-DOF IMU Driver API Reference","text":"<p>This document provides a detailed API reference for the <code>mpu9250_driver</code>, which interfaces with the TDK InvenSense MPU-9250 9-DOF inertial measurement unit (IMU). The driver is specifically designed for the Texas Instruments MSP-EXP432E401Y LaunchPad running the TI-RTOS real-time operating system.</p> <p>The driver is written in C and uses a handle-based interface (<code>MPU9250_Handle</code>), which encapsulates the entire state of the sensor instance. It's built to be robust, configurable, and provide a high-level interface for complex tasks like calibration and sensor fusion.</p>"},{"location":"api/c_driver/#key-features","title":"Key Features","text":"<ul> <li>Robust Initialization: Automatically detects MPU9250, MPU9255, and MPU6500 variants.</li> <li>Full Configuration: Provides easy-to-use structures for configuring sensor ranges, digital low-pass filters (DLPF), and sample rates.</li> <li>Automated Calibration: Includes functions to calculate biases and variances for the accelerometer, gyroscope, and magnetometer, which are essential for high-quality sensor fusion.</li> <li>Interactive Orientation Setup: A guided routine helps determine the physical orientation matrix of the sensor, removing the need for hard-coded coordinate transformations.</li> <li>Unified Sensor Fusion Module: Integrates Complementary, Madgwick, and Mahony filters for stable 6-DoF (Accel + Gyro) and 9-DoF (Accel + Gyro + Mag) orientation tracking.</li> <li>Comprehensive Error Handling: Returns detailed status codes for easier debugging.</li> </ul>"},{"location":"api/c_driver/#public-enums-and-structures","title":"Public Enums and Structures","text":"<p>These are the primary data types used to configure and interact with the driver. Understanding them is key to using the library effectively.</p>"},{"location":"api/c_driver/#status-codes-mpu9250_status_e","title":"Status Codes (<code>MPU9250_Status_e</code>)","text":"<p>This enum lists all possible return codes for functions that can fail, helping you diagnose issues in your application.</p> <ul> <li><code>MPU9250_OK</code>: Operation was successful.</li> <li><code>MPU9250_ERROR_INVALID_HANDLE</code>: The provided sensor handle was <code>NULL</code>.</li> <li><code>MPU9250_ERROR_MALLOC</code>: Failed to allocate memory for the handle.</li> <li><code>MPU9250_ERROR_I2C</code>: An I2C communication error occurred.</li> <li><code>MPU9250_ERROR_WHO_AM_I</code>: The device <code>WHO_AM_I</code> value was incorrect, meaning the wrong chip is connected or it's not responding.</li> <li><code>MPU9250_ERROR_TIMEOUT</code>: A timeout occurred waiting for a sensor event.</li> <li><code>MPU9250_ERROR_INVALID_PARAM</code>: An invalid parameter was passed to a function (e.g., <code>dt</code> was zero).</li> <li><code>MPU9250_ERROR_NOT_SUPPORTED</code>: The requested feature is not supported by the detected device.</li> </ul>"},{"location":"api/c_driver/#sensor-configuration-enums","title":"Sensor Configuration Enums","text":"<p>These enums allow you to configure the physical behavior of the sensor.</p> <ul> <li><code>AccelFSR_e</code> (Accelerometer Full-Scale Range):</li> <li><code>ACCEL_FS_2G</code>: +/- 2g</li> <li><code>ACCEL_FS_4G</code>: +/- 4g</li> <li><code>ACCEL_FS_8G</code>: +/- 8g</li> <li><code>ACCEL_FS_16G</code>: +/- 16g</li> <li><code>GyroFSR_e</code> (Gyroscope Full-Scale Range):</li> <li><code>GYRO_FS_250DPS</code>: +/- 250 degrees per second</li> <li><code>GYRO_FS_500DPS</code>: +/- 500 degrees per second</li> <li><code>GYRO_FS_1000DPS</code>: +/- 1000 degrees per second</li> <li><code>GYRO_FS_2000DPS</code>: +/- 2000 degrees per second</li> <li><code>AccelDLPF_e</code> (Accelerometer Digital Low-Pass Filter):</li> <li><code>ACCEL_DLPF_218HZ</code></li> <li><code>ACCEL_DLPF_99HZ</code></li> <li><code>ACCEL_DLPF_41HZ</code></li> <li><code>ACCEL_DLPF_20HZ</code></li> <li><code>ACCEL_DLPF_10HZ</code></li> <li><code>ACCEL_DLPF_5HZ</code></li> <li><code>GyroDLPF_e</code> (Gyroscope Digital Low-Pass Filter):</li> <li><code>GYRO_DLPF_184HZ</code></li> <li><code>GYRO_DLPF_92HZ</code></li> <li><code>GYRO_DLPF_41HZ</code></li> <li><code>GYRO_DLPF_20HZ</code></li> <li><code>GYRO_DLPF_10HZ</code></li> <li><code>GYRO_DLPF_5HZ</code></li> <li><code>MagMode_e</code> (Magnetometer Mode):</li> <li><code>MAG_MODE_8HZ</code>: 8 Hz continuous measurement.</li> <li><code>MAG_MODE_100HZ</code>: 100 Hz continuous measurement.</li> <li><code>MagOutput_e</code> (Magnetometer Resolution):</li> <li><code>MAG_OUT_14_BIT</code>: 14-bit output resolution.</li> <li><code>MAG_OUT_16_BIT</code>: 16-bit output resolution.</li> </ul>"},{"location":"api/c_driver/#sensor-fusion-enums","title":"Sensor Fusion Enums","text":"<p>These enums are used to control the sensor fusion module.</p> <ul> <li><code>FusionAlgorithm_e</code>:</li> <li><code>FUSION_ALGORITHM_COMPLEMENTARY</code>: Simple Complementary Filter.</li> <li><code>FUSION_ALGORITHM_MADGWICK</code>: Madgwick Gradient Descent AHRS.</li> <li><code>FUSION_ALGORITHM_MAHONY</code>: Mahony PI Controller AHRS.</li> <li><code>FusionDOF_e</code> (Degrees of Freedom):</li> <li><code>FUSION_DOF_6</code>: Use Accelerometer and Gyroscope only.</li> <li><code>FUSION_DOF_9</code>: Use Accelerometer, Gyroscope, and Magnetometer.</li> </ul>"},{"location":"api/c_driver/#core-data-structures","title":"Core Data Structures","text":"<ul> <li><code>MPU9250_Config</code>: This structure holds all the initial settings for the sensor. You populate it and pass it to <code>MPU9250_init</code>.</li> <li><code>uint8_t i2cAddress</code>: The I2C address of the sensor (0x68 or 0x69).</li> <li><code>AccelFSR_e accelFSR</code>: Accelerometer full-scale range.</li> <li><code>GyroFSR_e gyroFSR</code>: Gyroscope full-scale range.</li> <li><code>uint8_t sampleRateDivider</code>: Divides the internal 1kHz sample rate. <code>Sample Rate = 1kHz / (1 + divider)</code>.</li> <li><code>AccelDLPF_e accelDLPF</code>: Accelerometer Digital Low-Pass Filter setting.</li> <li><code>GyroDLPF_e gyroDLPF</code>: Gyroscope Digital Low-Pass Filter setting.</li> <li><code>MagMode_e magMode</code>: Magnetometer continuous measurement mode.</li> <li><code>MagOutput_e magOutput</code>: Magnetometer output bit resolution.</li> <li><code>MPU9250_Handle</code>: This is the main object for your sensor instance. It's created by <code>MPU9250_init</code> and holds the complete state of the driver and sensor.</li> <li>TI-RTOS Communication Handles<ul> <li><code>I2C_Handle i2cHandle</code>: Handle to the I2C peripheral from TI-RTOS.</li> <li><code>I2C_Transaction *i2cTransaction</code>: Pointer to a user-provided I2C transaction struct.</li> <li><code>uint8_t i2cAddress</code>: The I2C address of the sensor.</li> </ul> </li> <li>Sensor State &amp; Data<ul> <li><code>bool hasMag</code>: <code>true</code> if an AK8963 magnetometer is detected.</li> <li><code>MPU9250_Vector3D accelerometer</code>: Latest accelerometer reading in m/s\u00b2.</li> <li><code>MPU9250_Vector3D gyroscope</code>: Latest gyroscope reading in rad/s.</li> <li><code>MPU9250_Vector3D magnetometer</code>: Latest magnetometer reading in \u00b5T.</li> <li><code>float temperature</code>: Latest temperature reading in Celsius.</li> <li><code>float sampleRate</code>: The configured sample rate in Hz.</li> </ul> </li> <li>Calibration Data<ul> <li><code>MPU9250_Vector3D accelBias</code>, <code>gyroBias</code>, <code>magBias</code>: Biases (offsets) calculated by <code>MPU9250_calibrate</code> and automatically subtracted from raw readings.</li> <li><code>MPU9250_Vector3D accelVariance</code>, <code>gyroVariance</code>, <code>magVariance</code>: Measurement variances, useful for advanced filters like an EKF.</li> </ul> </li> <li>Internal Scale Factors<ul> <li><code>float accelScale</code>, <code>gyroScale</code>, <code>magScale</code>: Conversion factors from raw sensor values to physical units.</li> <li><code>MPU9250_Vector3D magAdjust</code>: Magnetometer sensitivity adjustments read from the sensor's internal ROM.</li> </ul> </li> <li>Sensor Fusion State<ul> <li><code>MPU9250_FusionState fusion</code>: A nested struct holding the state and results of the chosen fusion algorithm.</li> </ul> </li> </ul>"},{"location":"api/c_driver/#sensor-fusion-algorithms-explained","title":"Sensor Fusion Algorithms Explained","text":"<p>A raw IMU gives you noisy, drifting data. Sensor fusion algorithms combine the data from multiple sensors to produce a stable and accurate estimate of the device's orientation. This driver includes three popular algorithms.</p>"},{"location":"api/c_driver/#complementary-filter","title":"Complementary Filter","text":"<p>This is the simplest and most intuitive of the filters. It works in the frequency domain.</p> <ul> <li>Concept: It combines the gyroscope and accelerometer data by trusting each one in the domain where it performs best.</li> <li>Gyroscopes are good at tracking fast changes in orientation (high-frequency), but they drift over time.</li> <li>Accelerometers can determine the direction of gravity (and thus roll/pitch) when the device is still or moving slowly, making them a stable reference for slow changes (low-frequency).</li> <li>How it Works: The filter is essentially a weighted average. The new angle is calculated as:   <code>angle = \u03b1 * (previous_angle + gyro_rate * dt) + (1 - \u03b1) * accel_angle</code></li> <li>The <code>\u03b1</code> (alpha) parameter is a filter coefficient (e.g., 0.98). A higher value means you trust the gyroscope more, making the filter responsive but more prone to drift. A lower value trusts the accelerometer more, making it stable but sluggish.</li> <li>Pros: Computationally very cheap and easy to understand.</li> <li>Cons: Less accurate than other methods, especially during complex movements. Yaw (heading) can only be determined with a magnetometer and is also subject to drift if only using the gyro.</li> </ul>"},{"location":"api/c_driver/#madgwick-ahrs-filter","title":"Madgwick AHRS Filter","text":"<p>This is a much more sophisticated algorithm based on quaternions and gradient descent optimization.</p> <ul> <li>Concept: It uses the gyroscope to predict the orientation and then uses the accelerometer and magnetometer as a reference to correct for drift.</li> <li> <p>How it Works:</p> </li> <li> <p>The gyroscope data is integrated to predict the new orientation quaternion.</p> </li> <li>An \"objective function\" is created using the accelerometer and magnetometer data. This function represents the error between the orientation predicted by the gyro and the orientation measured by the reference sensors.</li> <li>A mathematical technique called gradient descent is used to find the direction in which the orientation quaternion needs to be adjusted to minimize this error.</li> <li> <p>The quaternion is adjusted in that direction by a small amount, controlled by the gain parameter <code>\u03b2</code> (beta). <code>\u03b2</code> represents the gyroscope measurement error; a higher value corrects the orientation more aggressively.</p> </li> <li> <p>Pros: Very accurate and robust across a wide range of motions. It's considered one of the gold standards for IMU orientation filtering.</p> </li> <li>Cons: More computationally expensive than the Complementary or Mahony filters.</li> </ul>"},{"location":"api/c_driver/#mahony-ahrs-filter","title":"Mahony AHRS Filter","text":"<p>The Mahony filter is another advanced quaternion-based filter that is computationally more efficient than the Madgwick filter.</p> <ul> <li>Concept: It works like a Proportional-Integral (PI) controller, a common concept in control theory. The \"error\" is the difference between the direction of gravity measured by the accelerometer and the direction of gravity estimated by the current orientation.</li> <li> <p>How it Works:</p> </li> <li> <p>The error between the measured and estimated reference vectors (gravity and magnetic north) is calculated.</p> </li> <li>This error is fed into a PI controller.</li> <li>The Proportional gain (<code>Kp</code>) makes an immediate correction to the orientation based on the current error. It's like pushing the estimate back towards the correct orientation.</li> <li>The Integral gain (<code>Ki</code>) accumulates the error over time. This term is used to estimate and cancel out the gyroscope's bias drift, which is the primary source of long-term error.</li> <li> <p>The output of the PI controller is used to correct the angular velocity from the gyroscope before it's integrated.</p> </li> <li> <p>Pros: Almost as accurate as the Madgwick filter but significantly less computationally intensive, making it ideal for microcontrollers with limited processing power.</p> </li> <li>Cons: Can be slightly less responsive than the Madgwick filter under very high-speed, complex motion.</li> </ul>"},{"location":"api/c_driver/#api-function-reference","title":"API Function Reference","text":"<p>All functions are exposed in <code>mpu9250_driver.h</code>.</p>"},{"location":"api/c_driver/#lifecycle-initialization","title":"Lifecycle &amp; Initialization","text":"<p><code>void MPU9250_getDefaultConfig(MPU9250_Config *config)</code></p> <ul> <li>Description: Fills a configuration structure with default, recommended settings for general-purpose use.</li> <li>Parameters:</li> <li><code>[out] config</code>: A pointer to the configuration structure to be populated.</li> </ul> <p><code>MPU9250_Status_e MPU9250_init(MPU9250_Handle **sensor_p, I2C_Handle i2c, I2C_Transaction *transaction, const MPU9250_Config *config)</code></p> <ul> <li>Description: Initializes the MPU9250 sensor. This is the first function that must be called. It allocates memory for the sensor handle, resets the device, verifies its identity (<code>WHO_AM_I</code>), and applies the settings from the configuration structure.</li> <li>Parameters:</li> <li><code>[out] sensor_p</code>: A pointer to the handle pointer (<code>MPU9250_Handle*</code>). The driver will allocate memory and store the address of the new handle here.</li> <li><code>[in] i2c</code>: A handle to an initialized TI-RTOS I2C peripheral.</li> <li><code>[in] transaction</code>: A pointer to a user-provided <code>I2C_Transaction</code> structure. The driver will use this for all I2C communication.</li> <li><code>[in] config</code>: A pointer to a configuration structure with the desired settings.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code on failure.</li> </ul> <p><code>void MPU9250_deinit(MPU9250_Handle *sensor)</code></p> <ul> <li>Description: Deinitializes the sensor and frees the memory allocated for the handle.</li> <li>Parameters:</li> <li><code>[in] sensor</code>: The handle to deinitialize.</li> </ul>"},{"location":"api/c_driver/#data-acquisition","title":"Data Acquisition","text":"<p><code>MPU9250_Status_e MPU9250_readSensors(MPU9250_Handle *sensor)</code></p> <ul> <li>Description: Performs a burst-read to fetch the latest data from the accelerometer, gyroscope, temperature sensor, and (if present) the magnetometer. It applies calibration biases and scaling factors to convert the raw data into standard physical units (m/s\u00b2, rad/s, \u00b5T, \u00b0C). The results are stored within the <code>sensor</code> handle (e.g., <code>sensor-&gt;accelerometer</code>, <code>sensor-&gt;gyroscope</code>).</li> <li>Parameters:</li> <li><code>[in,out] sensor</code>: Pointer to the initialized sensor handle.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code on failure.</li> </ul>"},{"location":"api/c_driver/#calibration-setup","title":"Calibration &amp; Setup","text":"<p><code>MPU9250_Status_e MPU9250_calibrate(MPU9250_Handle *sensor, uint16_t numSamples)</code></p> <ul> <li>Description: Performs a static calibration. It averages a number of samples to calculate the bias (offset) and variance for each sensor axis. These values are stored in the handle and automatically subtracted from future readings.</li> <li>Precondition: The device must be kept perfectly still and level during the calibration process.</li> <li>Parameters:</li> <li><code>[in,out] sensor</code>: Pointer to the initialized sensor handle.</li> <li><code>[in] numSamples</code>: The number of samples to collect and average (e.g., 1000). More samples yield better results but take longer.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code on failure.</li> </ul> <p><code>MPU9250_Status_e MPU9250_determineOrientationAxes(MPU9250_Handle *sensor, MPU9250_Matrix3x3 *matrix, ReferenceFrame_e frame)</code></p> <ul> <li>Description: Runs an interactive, two-step console routine to determine the sensor's physical orientation relative to a user-selected reference frame (<code>NED</code> or <code>ENU</code>). It populates a rotation matrix that can be used with <code>MPU9250_applyRotation</code> to transform sensor readings from the body frame to the selected world frame. The interactive process guides the user to first establish the vertical axis by measuring gravity and then find the forward (North) axis by performing a specific motion.</li> <li>Parameters:</li> <li><code>[in] sensor</code>: Pointer to the initialized and calibrated sensor handle.</li> <li><code>[out] matrix</code>: A pointer to a 3x3 matrix where the resulting orientation matrix will be stored.</li> <li><code>[in] frame</code>: The desired reference frame for calibration. This must be one of the values from the <code>ReferenceFrame_e</code> enum (<code>FRAME_NED</code> or <code>FRAME_ENU</code>).</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code on failure.</li> </ul>"},{"location":"api/c_driver/#reference-frames-explained","title":"Reference Frames Explained","text":"<p>The <code>frame</code> parameter allows you to align the sensor's data with one of two common coordinate systems used in navigation and robotics.</p> <ul> <li>NED (North-East-Down)</li> </ul> <p>This is a local tangent plane frame commonly used in aerospace and aviation applications.</p> <ul> <li>X-axis: Points to true North.</li> <li>Y-axis: Points to true East.</li> <li>Z-axis: Points Down, towards the center of the Earth.</li> <li>ENU (East-North-Up)</li> </ul> <p>This frame is widely used in geodetic, surveying, and ground-based robotics applications.</p> <ul> <li>X-axis: Points to true East.</li> <li>Y-axis: Points to true North.</li> <li>Z-axis: Points Up, away from the center of the Earth.</li> </ul> <p><code>void MPU9250_applyRotation(const MPU9250_Matrix3x3 *matrix, MPU9250_Vector3D *vector)</code></p> <ul> <li>Description: A utility function to apply a coordinate transformation to a 3D vector using a rotation matrix (<code>V_rotated = R * V_original</code>). This is useful for rotating sensor data from the body frame to the world frame before sensor fusion.</li> <li>Parameters:</li> <li><code>[in] matrix</code>: Pointer to the 3x3 rotation matrix.</li> <li><code>[in,out] vector</code>: Pointer to the vector to be rotated. The operation is done in-place.</li> </ul>"},{"location":"api/c_driver/#sensor-fusion","title":"Sensor Fusion","text":"<p><code>MPU9250_Status_e MPU9250_SensorFusionInit(MPU9250_Handle *sensor, FusionAlgorithm_e algorithm, const void *params)</code></p> <ul> <li>Description: Initializes the sensor fusion module. This sets the desired algorithm and its associated parameters (e.g., filter gain).</li> <li>Parameters:</li> <li><code>[in,out] sensor</code>: Pointer to the sensor handle.</li> <li><code>[in] algorithm</code>: The fusion algorithm to use (e.g., <code>FUSION_ALGORITHM_MADGWICK</code>).</li> <li><code>[in] params</code>: A void pointer to a parameter structure corresponding to the chosen algorithm (e.g., a <code>MadgwickFilterParams</code> struct).</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code.</li> </ul> <p><code>MPU9250_Status_e MPU9250_SensorFusionUpdate(MPU9250_Handle *sensor, FusionDOF_e dof, float dt)</code></p> <ul> <li>Description: Runs one iteration of the configured fusion algorithm. It uses the latest sensor data stored in the handle to update the orientation estimate. The result is stored internally in <code>sensor-&gt;fusion.orientation</code>.</li> <li> <p>Preconditions:</p> </li> <li> <p><code>MPU9250_readSensors()</code> should be called immediately before this function to get fresh data.</p> </li> <li> <p>For best results, sensor data should be transformed to the world frame via <code>MPU9250_applyRotation()</code> before calling this function.</p> </li> <li> <p>Parameters:</p> </li> <li><code>[in,out] sensor</code>: Pointer to the sensor handle.</li> <li><code>[in] dof</code>: The degrees of freedom to use for the update (<code>FUSION_DOF_6</code> for Accel+Gyro, <code>FUSION_DOF_9</code> for Accel+Gyro+Mag).</li> <li><code>[in] dt</code>: The time elapsed since the last update, in seconds. This is critical for accurate integration.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code.</li> </ul>"},{"location":"api/c_driver/#data-retrieval","title":"Data Retrieval","text":"<p><code>MPU9250_Status_e MPU9250_getOrientation(MPU9250_Handle *sensor, MPU9250_Quaternion *q)</code></p> <ul> <li>Description: Gets the current orientation calculated by the fusion filter as a quaternion.</li> <li>Parameters:</li> <li><code>[in] sensor</code>: Pointer to the sensor handle.</li> <li><code>[out] q</code>: Pointer to a quaternion structure where the result will be stored.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code.</li> </ul> <p><code>MPU9250_Status_e MPU9250_getEulerAngles(MPU9250_Handle *sensor, MPU9250_EulerAngles *angles)</code></p> <ul> <li>Description: Gets the current orientation as Euler angles (roll, pitch, yaw). It converts the internal orientation quaternion to Euler angles in  radians.</li> <li>Parameters:</li> <li><code>[in] sensor</code>: Pointer to the sensor handle.</li> <li><code>[out] angles</code>: Pointer to an <code>MPU9250_EulerAngles</code> structure where the result will be stored.</li> <li>Returns: <code>MPU9250_OK</code> on success, or an error code.</li> </ul>"},{"location":"api/c_driver/#example-usage-ti-rtos","title":"Example Usage (TI-RTOS)","text":"<p>This example demonstrates the typical usage pattern for the MPU9250 driver within a TI-RTOS task.</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;xdc/runtime/System.h&gt;\n#include &lt;ti/sysbios/knl/Task.h&gt;\n#include &lt;ti/sysbios/knl/Clock.h&gt;\n#include &lt;ti/drivers/I2C.h&gt;\n#include \"ti_drivers_config.h\" // Generated by SysConfig\n\n#include \"MPU9250.h\"\n\n#define SENSOR_UPDATE_PERIOD_MS 10 // For a 100 Hz update rate\n\nvoid sensorTaskFxn(UArg arg0, UArg arg1) {\n    I2C_Handle i2cHandle;\n    I2C_Params i2cParams;\n    I2C_Transaction i2cTransaction;\n\n    MPU9250_Handle *sensor_handle = NULL;\n    MPU9250_Config sensor_config;\n    MPU9250_EulerAngles euler_angles;\n\n    /* 1. Initialize I2C Driver */\n    I2C_Params_init(&amp;i2cParams);\n    i2cParams.bitRate = I2C_400kHz;\n    i2cHandle = I2C_open(CONFIG_I2C_0, &amp;i2cParams);\n    if (i2cHandle == NULL) {\n        System_printf(\"Error Initializing I2C\\n\");\n        System_flush();\n        while (1);\n    }\n\n    // Configure the transaction struct. This will be used by the driver.\n    i2cTransaction.readBuf = NULL;\n    i2cTransaction.readCount = 0;\n    i2cTransaction.writeBuf = NULL;\n    i2cTransaction.writeCount = 0;\n\n    /* 2. Initialize the MPU9250 Driver */\n    MPU9250_getDefaultConfig(&amp;sensor_config); // Start with defaults\n    sensor_config.accelFSR = ACCEL_FS_4G;\n    sensor_config.gyroFSR = GYRO_FS_500DPS;\n    sensor_config.sampleRateDivider = 9; // Sets sample rate to 1kHz / (1+9) = 100Hz\n\n    if (MPU9250_init(&amp;sensor_handle, i2cHandle, &amp;i2cTransaction, &amp;sensor_config) != MPU9250_OK) {\n        System_printf(\"Failed to initialize MPU9250 sensor.\\n\");\n        System_flush();\n        while (1);\n    }\n    System_printf(\"MPU9250 Initialized.\\n\");\n    System_flush();\n\n    /* 3. Calibrate the sensor */\n    System_printf(\"Calibrating... Keep the sensor still.\\n\");\n    System_flush();\n    if (MPU9250_calibrate(sensor_handle, 1000) != MPU9250_OK) {\n        System_printf(\"Calibration failed.\\n\");\n        System_flush();\n        while(1);\n    }\n    System_printf(\"Calibration complete.\\n\");\n    System_flush();\n\n    /* 4. Initialize the Sensor Fusion Module (using Madgwick) */\n    MadgwickFilterParams fusion_params = {.beta = 0.1f};\n    if (MPU9250_SensorFusionInit(sensor_handle, FUSION_ALGORITHM_MADGWICK, &amp;fusion_params) != MPU9250_OK) {\n        System_printf(\"Failed to init sensor fusion.\\n\");\n        System_flush();\n        while(1);\n    }\n    System_printf(\"Sensor Fusion Initialized. Reading data...\\n\");\n    System_flush();\n\n    float dt = (float)SENSOR_UPDATE_PERIOD_MS / 1000.0f;\n\n    /* 5. Main loop to read and process data */\n    while (1) {\n        // Delay to maintain a consistent update rate\n        Task_sleep(SENSOR_UPDATE_PERIOD_MS * 1000 / Clock_tickPeriod);\n\n        // Read the latest sensor data\n        if (MPU9250_readSensors(sensor_handle) == MPU9250_OK) {\n\n            // Update the fusion algorithm with the new data\n            MPU9250_SensorFusionUpdate(sensor_handle, FUSION_DOF_9, dt);\n\n            // Get the resulting orientation in Euler angles\n            MPU9250_getEulerAngles(sensor_handle, &amp;euler_angles);\n\n            // Convert radians to degrees for printing\n            float roll_deg = euler_angles.roll * 180.0f / M_PI;\n            float pitch_deg = euler_angles.pitch * 180.0f / M_PI;\n            float yaw_deg = euler_angles.yaw * 180.0f / M_PI;\n\n            System_printf(\"Roll: %.2f, Pitch: %.2f, Yaw: %.2f\\n\", roll_deg, pitch_deg, yaw_deg);\n            System_flush();\n        }\n    }\n}\n</code></pre>"},{"location":"api/cpp_class/","title":"MPU6500/9250 DMP Driver API Reference","text":"<p>This document provides a detailed API reference for the <code>MPU_DMP</code> driver, which interfaces with InvenSense MPU6500 and MPU9250 inertial measurement units (IMUs). The driver simplifies the use of the sensor's on-board Digital Motion Processor (DMP) to retrieve stable, quaternion-based orientation data.</p> <p>The library is written in C++ but provides a complete C wrapper API for use in C-only projects. This is achieved through an opaque pointer (MPU_DMP_Handle), which conceals the underlying C++ object implementation.</p>"},{"location":"api/cpp_class/#key-features","title":"Key Features","text":"<ul> <li>Simplified initialization of the MPU and DMP.</li> <li>Easy configuration of sensor parameters like Full-Scale Range (FSR) and sample rates.</li> <li>DMP feature support, including 6-axis quaternion fusion, tap detection, and pedometer.</li> <li>Direct access to raw sensor data and DMP-processed quaternions.</li> <li>Helper functions to convert raw data and calculate Euler angles (pitch, roll, yaw).</li> <li>Conditional support for the MPU9250's magnetometer.</li> </ul>"},{"location":"api/cpp_class/#c-api-reference-mpu_dmp-class","title":"C++ API Reference (<code>MPU_DMP</code> Class)","text":"<p>This is the core object-oriented interface. To use it, include <code>MPU_DMP.h</code> in your project.</p>"},{"location":"api/cpp_class/#public-data-members","title":"Public Data Members","text":"<p>After a successful call to <code>dmpUpdateFifo()</code>, these members are populated with the latest data from the sensor.</p> <ul> <li><code>int ax, ay, az;</code></li> <li>Raw accelerometer data for X, Y, and Z axes.</li> <li><code>int gx, gy, gz;</code></li> <li>Raw gyroscope data for X, Y, and Z axes.</li> <li><code>long qw, qx, qy, qz;</code></li> <li>Raw quaternion data (W, X, Y, Z) from the DMP in Q30 fixed-point format.</li> <li><code>unsigned long time;</code></li> <li>Timestamp for the last DMP data packet.</li> <li><code>float pitch, roll, yaw;</code></li> <li>Calculated Euler angles. These are only updated after you call <code>computeEulerAngles()</code>.</li> </ul>"},{"location":"api/cpp_class/#mpu9250-specific-members","title":"MPU9250 Specific Members","text":"<p>These members are only available if the <code>USE_MPU9250</code> macro is defined.</p> <ul> <li><code>int mx, my, mz;</code></li> <li> <p>Raw magnetometer data. Note: This is not read from the DMP FIFO and must be fetched separately.</p> </li> <li> <p><code>float heading;</code></p> </li> <li>Calculated compass heading. Updated by calling <code>computeCompassHeading()</code>.</li> </ul>"},{"location":"api/cpp_class/#core-methods","title":"Core Methods","text":""},{"location":"api/cpp_class/#initialization-status","title":"Initialization &amp; Status","text":"<p><code>MPU_DMP()</code></p> <ul> <li>Description: The class constructor. Initializes internal variables.</li> </ul> <p><code>int begin()</code></p> <ul> <li>Description: Initializes the MPU sensor hardware and the underlying motion driver. This must be called before any other function.</li> <li>Returns: <code>INV_SUCCESS</code> (0) on success, <code>INV_ERROR</code> (-1) on failure.</li> </ul> <p><code>int selfTest()</code></p> <ul> <li>Description: Runs the sensor's built-in self-test routine to verify hardware functionality.</li> <li>Returns: A bitmask of test results. For MPU6500, a result of <code>0x03</code> means gyro and accel passed. For MPU9250, a result of <code>0x07</code> means all three sensors passed.</li> </ul>"},{"location":"api/cpp_class/#dmp-digital-motion-processor-functions","title":"DMP (Digital Motion Processor) Functions","text":"<p><code>int dmpBegin(unsigned short features, unsigned short fifoRate = 100)</code></p> <ul> <li>Description: Loads the DMP firmware, enables specified features, and starts the DMP. This is the primary function to begin motion processing.</li> <li>Parameters:</li> <li><code>features</code>: A bitmask of DMP features to enable. Available features:<ul> <li><code>DMP_FEATURE_LP_QUAT</code>: Generates quaternions from the gyroscope data only (3-axis fusion). This is less accurate but consumes less power.</li> <li><code>DMP_FEATURE_6X_LP_QUAT</code>: Generates quaternions using data from both the gyroscope and accelerometer (6-axis sensor fusion). This provides a more stable orientation and corrects for gyro drift. This is the most commonly used feature for orientation tracking.</li> <li><code>DMP_FEATURE_TAP</code>: Enables tap detection. When a tap is detected, the DMP will generate an interrupt.</li> <li><code>DMP_FEATURE_ANDROID_ORIENT</code>: Enables the DMP to determine the screen orientation (portrait, landscape, etc.) based on gravity, similar to an Android phone.</li> <li><code>DMP_FEATURE_PEDOMETER</code>: Enables the built-in step counter.</li> <li><code>DMP_FEATURE_GYRO_CAL</code>: Enables continuous calibration of the gyroscope at runtime, helping to reduce drift.</li> <li><code>DMP_FEATURE_SEND_RAW_ACCEL</code>: Sends raw accelerometer data to the FIFO buffer.</li> <li><code>DMP_FEATURE_SEND_RAW_GYRO</code>: Sends raw gyroscope data to the FIFO buffer.</li> <li><code>DMP_FEATURE_SEND_CAL_GYRO</code>: Sends calibrated gyroscope data to the FIFO buffer.</li> </ul> </li> <li><code>fifoRate</code>: The desired rate in Hz for the DMP to generate new data packets (e.g., 100 Hz).</li> <li>Returns: <code>INV_SUCCESS</code> (0) on success, <code>INV_ERROR</code> (-1) on failure.</li> </ul> <p><code>int dmpUpdateFifo()</code></p> <ul> <li>Description: Reads the latest data packet from the DMP's FIFO buffer. This function should be called repeatedly in your main loop. If a new packet is available, it updates the public data members (<code>ax</code>, <code>ay</code>, <code>az</code>, <code>gx</code>, <code>gy</code>, <code>gz</code>, <code>qw</code>, <code>qx</code>, <code>qy</code>, <code>qz</code>).</li> <li>Returns: <code>INV_SUCCESS</code> (0) if a new packet was read, <code>INV_ERROR</code> (-1) if no new data was available.</li> </ul>"},{"location":"api/cpp_class/#data-calculation-conversion","title":"Data Calculation &amp; Conversion","text":"<p><code>void computeEulerAngles(bool degrees = true)</code></p> <ul> <li>Description: Computes pitch, roll, and yaw from the current quaternion data (<code>qw</code>, <code>qx</code>, <code>qy</code>, <code>qz</code>). The results are stored in the public <code>pitch</code>, <code>roll</code>, and <code>yaw</code> members.</li> <li>Parameters:</li> <li><code>degrees</code>: If <code>true</code> (default), the results are in degrees. If <code>false</code>, they are in radians.</li> </ul> <p><code>float calcAccel(int axis_val)</code></p> <ul> <li>Description: Converts a raw accelerometer integer value to physical units (g's).</li> <li>Returns: The acceleration in g's.</li> </ul> <p><code>float calcGyro(int axis_val)</code></p> <p>Description: Converts a raw gyroscope integer value to physical units (degrees per second). Returns: The angular velocity in degrees per second.</p> <p><code>float calcQuat(long quat_val)</code></p> <p>Description: Converts a raw Q30 format quaternion value from the DMP into a standard floating-point number. Returns: The floating-point quaternion component.</p>"},{"location":"api/cpp_class/#sensor-configuration","title":"Sensor Configuration","text":"<p><code>int setSensors(unsigned char sensors)</code>: Enables or disables sensors using a bitmask. Available flags are:</p> <ul> <li><code>INV_XYZ_GYRO</code>: Enables the X, Y, and Z axes of the gyroscope.</li> <li><code>INV_XYZ_ACCEL</code>: Enables the X, Y, and Z axes of the accelerometer.</li> <li><code>INV_XYZ_COMPASS</code>: Enables the X, Y, and Z axes of the magnetometer (compass). This is only applicable for MPU9250 devices and requires <code>USE_MPU9250</code> to be defined.</li> </ul> <p><code>int setGyroFSR(unsigned short fsr)</code>: Sets the gyroscope's full-scale range (250, 500, 1000 or 2000 dps).</p> <p><code>int setAccelFSR(unsigned char fsr)</code>: Sets the accelerometer's full-scale range (2, 4, 8 or 16 g).</p> <p><code>int setLPF(unsigned short lpf)</code>: Sets the digital low-pass filter cutoff frequency in Hz.</p> <p><code>int setSampleRate(unsigned short rate)</code>: Sets the raw sensor sample rate in Hz.</p> <p><code>unsigned short getGyroFSR()</code>: Gets the current gyro FSR.</p> <p><code>unsigned char getAccelFSR()</code>: Gets the current accel FSR.</p>"},{"location":"api/cpp_class/#c-api-reference-opaque-pointer","title":"C API Reference (Opaque Pointer)","text":"<p>This C-compatible API provides all the functionality of the C++ class. It is designed for C projects or for creating wrappers in other languages. To use it, include <code>MPU_DMP_C.h</code>.</p> <p>All functions operate on an <code>MPU_DMP_Handle</code>, which is an opaque pointer to the underlying C++ object.</p>"},{"location":"api/cpp_class/#lifecycle-functions","title":"Lifecycle Functions","text":"<p><code>MPU_DMP_Handle MPU_DMP_Create()</code></p> <ul> <li>Description: Allocates and creates a new <code>MPU_DMP</code> instance.</li> <li>Returns: A handle to the new instance, or <code>NULL</code> on failure. This handle must be used in all subsequent API calls.</li> </ul> <p><code>void MPU_DMP_Destroy(MPU_DMP_Handle handle)</code></p> <ul> <li>Description: Frees all resources associated with an <code>MPU_DMP</code> instance.</li> <li>Parameters:</li> <li><code>handle</code>: The handle returned by <code>MPU_DMP_Create()</code>.</li> </ul>"},{"location":"api/cpp_class/#core-functions","title":"Core Functions","text":"<p>The C functions map directly to their C++ counterparts. The primary difference is that they all take an <code>MPU_DMP_Handle</code> as their first argument.</p> <ul> <li><code>int MPU_DMP_begin(MPU_DMP_Handle handle)</code></li> <li><code>int MPU_DMP_dmpBegin(MPU_DMP_Handle handle, unsigned short features, unsigned short fifoRate)</code></li> <li><code>int MPU_DMP_dmpUpdateFifo(MPU_DMP_Handle handle)</code></li> <li><code>int MPU_DMP_computeEulerAngles(MPU_DMP_Handle handle, bool degrees)</code></li> </ul>"},{"location":"api/cpp_class/#data-accessor-functions","title":"Data Accessor Functions","text":"<p>Since C cannot directly access the C++ object's members, getter functions are provided to retrieve the sensor data after a call to <code>MPU_DMP_dmpUpdateFifo()</code>.</p>"},{"location":"api/cpp_class/#processed-euler-angles","title":"Processed Euler Angles","text":"<p><code>float MPU_DMP_get_pitch(MPU_DMP_Handle handle)</code> <code>float MPU_DMP_get_roll(MPU_DMP_Handle handle)</code> <code>float MPU_DMP_get_yaw(MPU_DMP_Handle handle)</code></p>"},{"location":"api/cpp_class/#raw-quaternion-data","title":"Raw Quaternion Data","text":"<p><code>long MPU_DMP_get_qw(MPU_DMP_Handle handle)</code> <code>long MPU_DMP_get_qx(MPU_DMP_Handle handle)</code> <code>long MPU_DMP_get_qy(MPU_DMP_Handle handle)</code> <code>long MPU_DMP_get_qz(MPU_DMP_Handle handle)</code></p>"},{"location":"api/cpp_class/#raw-accelerometer-data","title":"Raw Accelerometer Data","text":"<p><code>int MPU_DMP_get_ax(MPU_DMP_Handle handle)</code> <code>int MPU_DMP_get_ay(MPU_DMP_Handle handle)</code> <code>int MPU_DMP_get_az(MPU_DMP_Handle handle)</code></p>"},{"location":"api/cpp_class/#raw-gyroscope-data","title":"Raw Gyroscope Data","text":"<p><code>int MPU_DMP_get_gx(MPU_DMP_Handle handle)</code> <code>int MPU_DMP_get_gy(MPU_DMP_Handle handle)</code> <code>int MPU_DMP_get_gz(MPU_DMP_Handle handle)</code></p>"},{"location":"api/cpp_class/#example-usage","title":"Example Usage","text":""},{"location":"api/cpp_class/#c-example-arduino-environment","title":"C++ Example (Arduino Environment)","text":"<p>This example demonstrates the typical usage pattern for the MPU_DMP class.</p> <pre><code>#include &lt;Wire.h&gt;\n#include \"MPU_DMP.h\"\n\n// Create an MPU_DMP object\nMPU_DMP mpu;\n\nvoid setup() {\n    Serial.begin(115200);\n    Wire.begin();\n\n    // Initialize the MPU\n    if (mpu.begin() != INV_SUCCESS) {\n        Serial.println(\"Failed to initialize MPU!\");\n        while (1);\n    }\n\n    // Enable the DMP, using 6-axis quaternion fusion\n    // Set FIFO rate to 100Hz\n    if (mpu.dmpBegin(DMP_FEATURE_6X_LP_QUAT, 100) != INV_SUCCESS) {\n        Serial.println(\"Failed to start DMP!\");\n        while (1);\n    }\n\n    Serial.println(\"MPU and DMP initialized successfully.\");\n}\n\nvoid loop() {\n    // Check if new DMP data is available\n    if (mpu.dmpUpdateFifo() == INV_SUCCESS) {\n        // If yes, compute the Euler angles\n        mpu.computeEulerAngles();\n\n        // Print the results\n        Serial.print(\"Yaw: \");\n        Serial.print(mpu.yaw);\n        Serial.print(\", Pitch: \");\n        Serial.print(mpu.pitch);\n        Serial.print(\", Roll: \");\n        Serial.println(mpu.roll);\n    }\n\n    // A small delay is good practice\n    delay(10);\n}\n</code></pre>"},{"location":"api/cpp_class/#c-example-ti-rtos","title":"C Example (TI-RTOS)","text":"<p>This example shows how to use the C API with the opaque pointer.</p> <pre><code>/* STD header files */\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stddef.h&gt;\n\n/* XDCtools Header files */\n#include &lt;xdc/std.h&gt;\n#include &lt;xdc/runtime/Log.h&gt;\n#include &lt;xdc/runtime/Diags.h&gt;\n#include &lt;xdc/runtime/System.h&gt;\n\n/* BIOS Header files */\n#include &lt;ti/sysbios/BIOS.h&gt;\n#include &lt;ti/sysbios/knl/Task.h&gt;\n\n/* TI-RTOS Header files */\n#include &lt;ti/drivers/I2C.h&gt;\n#include &lt;ti/drivers/Board.h&gt;\n\n/* Board */\n#include \"ti_drivers_config.h\"\n\n/* MPU Driver Header */\n#include \"lib/MPU_DMP_C.h\"\n#include \"lib/util/inv_mpu.h\"\n#include \"lib/util/inv_mpu_dmp_motion_driver.h\"\n\n/* Extern declaration for the I2C handle used by the HAL */\nextern I2C_Handle i2c_handle;\n\n/*\n * ======== mpuTaskFxn ========\n * Task to initialize and read data from the MPU-6500.\n */\nvoid mpuTaskFxn(UArg arg0, UArg arg1) {\n    /* 1. Initialize I2C Driver and set the global handle */\n    I2C_Params i2cParams;\n    I2C_Params_init(&amp;i2cParams);\n    i2cParams.bitRate = I2C_400kHz;\n    i2c_handle = I2C_open(Board_I2C0, &amp;i2cParams);\n\n    if (i2c_handle == NULL) {\n        System_printf(\"Error Initializing I2C\\n\");\n        System_flush();\n        while (1);\n    }\n\n    /* 2. Create the MPU_DMP instance */\n    MPU_DMP_Handle mpu_handle = MPU_DMP_Create();\n    if (!mpu_handle) {\n        System_printf(\"Failed to create MPU_DMP handle.\\n\");\n        System_flush();\n        while (1);\n    }\n\n    /* 3. Initialize the sensor */\n    if (MPU_DMP_begin(mpu_handle) != INV_SUCCESS) {\n        System_printf(\"Failed to initialize MPU sensor.\\n\");\n        System_flush();\n        while (1);\n    }\n    System_printf(\"MPU initialized.\\n\");\n    System_flush();\n\n    /* 4. Initialize the DMP with 6-axis quaternion feature at 100Hz */\n    unsigned short dmp_features = DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_CAL;\n    if (MPU_DMP_dmpBegin(mpu_handle, dmp_features, 100) != INV_SUCCESS) {\n        System_printf(\"Failed to start DMP.\\n\");\n        System_flush();\n        while (1);\n    }\n    System_printf(\"DMP started. Reading data...\\n\");\n    System_flush();\n\n    /* 5. Main loop to read and process data */\n    while (1) {\n        // Try to read a new packet from the FIFO\n        if (MPU_DMP_dmpUpdateFifo(mpu_handle) == INV_SUCCESS) {\n            // New data is available, compute Euler angles in degrees\n            MPU_DMP_computeEulerAngles(mpu_handle, true);\n\n            // Get the calculated angles using accessor functions\n            float yaw = MPU_DMP_get_yaw(mpu_handle);\n            float pitch = MPU_DMP_get_pitch(mpu_handle);\n            float roll = MPU_DMP_get_roll(mpu_handle);\n\n            System_printf(\"Yaw: %.2f, Pitch: %.2f, Roll: %.2f\\n\", yaw, pitch, roll);\n            System_flush();\n        }\n\n        // Let other tasks run. Sleep for 10ms.\n        // Task_sleep() takes system ticks as an argument.\n        Task_sleep(10 * 1000 / Clock_tickPeriod);\n    }\n}\n</code></pre>"}]}