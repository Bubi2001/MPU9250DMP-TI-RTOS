# MPU-9250 and MPU-6500 Driver for TI-RTOS

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A comprehensive, easy-to-use I2C driver for the MPU-9250 IMU and MPU-6500 IMU, specifically tailored for the **TI-RTOS** environment on the **MSP-EXP432E401Y** platform. This library offers multiple levels of abstraction to get you up and running quickly.

This library provides everything you need to go from raw sensor readings to a fully calibrated, high-performance orientation solution.

## Features

- **Multi-Level API:** Choose the abstraction level that fits your needs:
  - A C library for direct register access, raw data and a complete sensor fusion hub.
  - A high-level C++ class that encapsulates the complex InvenSense DMP.
  - A C-compatible wrapper for using the DMP from any C project.
- **Sensor Fusion Options:** Includes a full implementation of the onboard **Digital Motion Processor (DMP)** for 6-axis quaternion output. The low-level C library includes options for simple **Complementary Filter** as well as advanced  **Madgwick and Mahony Filters** for either 6-axis or 9-axis quaternion output, with the possibility to convert to Euler Angles directly.
- **TI-RTOS Integration:** Designed from the ground up for a real-time, task-based environment, using TI Drivers for I2C and TI-RTOS primitives for timing.

## Library Versions & Getting Started

The library is split into three parts, located in the `lib/` directory.

Read the full [API reference](https://bubi2001.github.io/MPU9250DMP-TI-RTOS/) for specific methods and functions availables

### 1. Base C Library (`MPU9250.h`/`.c`)

This is a low-level C driver for initializing the sensor and getting raw, calibrated data. It includes a calibration routine to detect biases of sensors as well as variances in order to use high performance Sensor Fusion algorithms like an Extended Kalman Filter. It includes a routine to detect the orientation matrix ftom the body frame to a reference frame like **ENU** (East-North-Up) or **NED** (North-East-Down), more details on the reference frames can be found at the [API Reference](https://bubi2001.github.io/MPU9250DMP-TI-RTOS/api/c_driver/#reference-frames-explained). Lastly there are three Sensor Fusion Algorithms included, a **Complementary Filter**, a **Madgwick Filter** and a **Mahony Filter** each of them can operate in either 6-DoF (Accelerometer + Gyroscope) or 9-DoF (Accelerometer + Gyroscope + Magnetometer).

Example Usage (TI-RTOS):

```c
#include <stdint.h>
#include <xdc/runtime/System.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/knl/Clock.h>
#include <ti/drivers/I2C.h>
#include "ti_drivers_config.h" // Generated by SysConfig

#include "MPU9250.h"

#define SENSOR_UPDATE_PERIOD_MS 10 // For a 100 Hz update rate

void sensorTaskFxn(UArg arg0, UArg arg1) {
    I2C_Handle i2cHandle;
    I2C_Params i2cParams;
    I2C_Transaction i2cTransaction;

    MPU9250_Handle *sensor_handle = NULL;
    MPU9250_Config sensor_config;
    MPU9250_EulerAngles euler_angles;

    /* 1. Initialize I2C Driver */
    I2C_Params_init(&i2cParams);
    i2cParams.bitRate = I2C_400kHz;
    i2cHandle = I2C_open(CONFIG_I2C_0, &i2cParams);
    if (i2cHandle == NULL) {
        System_printf("Error Initializing I2C\n");
        System_flush();
        while (1);
    }

    // Configure the transaction struct. This will be used by the driver.
    i2cTransaction.readBuf = NULL;
    i2cTransaction.readCount = 0;
    i2cTransaction.writeBuf = NULL;
    i2cTransaction.writeCount = 0;

    /* 2. Initialize the MPU9250 Driver */
    MPU9250_getDefaultConfig(&sensor_config); // Start with defaults
    sensor_config.accelFSR = ACCEL_FS_4G;
    sensor_config.gyroFSR = GYRO_FS_500DPS;
    sensor_config.sampleRateDivider = 9; // Sets sample rate to 1kHz / (1+9) = 100Hz

    if (MPU9250_init(&sensor_handle, i2cHandle, &i2cTransaction, &sensor_config) != MPU9250_OK) {
        System_printf("Failed to initialize MPU9250 sensor.\n");
        System_flush();
        while (1);
    }
    System_printf("MPU9250 Initialized.\n");
    System_flush();

    /* 3. Calibrate the sensor */
    System_printf("Calibrating... Keep the sensor still.\n");
    System_flush();
    if (MPU9250_calibrate(sensor_handle, 1000) != MPU9250_OK) {
        System_printf("Calibration failed.\n");
        System_flush();
        while(1);
    }
    System_printf("Calibration complete.\n");
    System_flush();

    /* 4. Initialize the Sensor Fusion Module (using Madgwick) */
    MadgwickFilterParams fusion_params = {.beta = 0.1f};
    if (MPU9250_SensorFusionInit(sensor_handle, FUSION_ALGORITHM_MADGWICK, &fusion_params) != MPU9250_OK) {
        System_printf("Failed to init sensor fusion.\n");
        System_flush();
        while(1);
    }
    System_printf("Sensor Fusion Initialized. Reading data...\n");
    System_flush();

    float dt = (float)SENSOR_UPDATE_PERIOD_MS / 1000.0f;

    /* 5. Main loop to read and process data */
    while (1) {
        // Delay to maintain a consistent update rate
        Task_sleep(SENSOR_UPDATE_PERIOD_MS * 1000 / Clock_tickPeriod);

        // Read the latest sensor data
        if (MPU9250_readSensors(sensor_handle) == MPU9250_OK) {

            // Update the fusion algorithm with the new data
            MPU9250_SensorFusionUpdate(sensor_handle, FUSION_DOF_9, dt);

            // Get the resulting orientation in Euler angles
            MPU9250_getEulerAngles(sensor_handle, &euler_angles);

            // Convert radians to degrees for printing
            float roll_deg = euler_angles.roll * 180.0f / M_PI;
            float pitch_deg = euler_angles.pitch * 180.0f / M_PI;
            float yaw_deg = euler_angles.yaw * 180.0f / M_PI;

            System_printf("Roll: %.2f, Pitch: %.2f, Yaw: %.2f\n", roll_deg, pitch_deg, yaw_deg);
            System_flush();
        }
    }
}
```

### 2. C++ DMP Wrapper (`MPU_DMP.h`/`.cpp`)

A modern C++ class that wraps the complex, proprietary InvenSense DMP driver, providing a clean, object-oriented API. This is the recommended way to use the DMP in a C++ project.

Example Usage (Arduino-like Environment):

```cpp
#include <Wire.h>
#include "lib/MPU_DMP.h"
#include "lib/util/inv_imu.h"
#include "lib/util/inv_imu_dmp_motion_driver.h"

// Create an MPU_DMP object
MPU_DMP mpu;

void setup() {
    Serial.begin(115200);
    Wire.begin();

    // Initialize the MPU
    if (mpu.begin() != INV_SUCCESS) {
        Serial.println("Failed to initialize MPU!");
        while (1);
    }

    // Enable the DMP, using 6-axis quaternion fusion
    // Set FIFO rate to 100Hz
    if (mpu.dmpBegin(DMP_FEATURE_6X_LP_QUAT, 100) != INV_SUCCESS) {
        Serial.println("Failed to start DMP!");
        while (1);
    }
  
    Serial.println("MPU and DMP initialized successfully.");
}

void loop() {
    // Check if new DMP data is available
    if (mpu.dmpUpdateFifo() == INV_SUCCESS) {
        // If yes, compute the Euler angles
        mpu.computeEulerAngles();

        // Print the results
        Serial.print("Yaw: ");
        Serial.print(mpu.yaw);
        Serial.print(", Pitch: ");
        Serial.print(mpu.pitch);
        Serial.print(", Roll: ");
        Serial.println(mpu.roll);
    }

    // A small delay is good practice
    delay(10);
}
```

### 3. C-Compatible DMP Wrapper (`MPU_DMP_C.h`/`.cpp`)

A C-style wrapper that allows you to safely use the C++ DMP class from a standard C project using an opaque pointer.

Example Usage (TI-RTOS):

```c
/* STD header files */
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

/* XDCtools Header files */
#include <xdc/std.h>
#include <xdc/runtime/Log.h>
#include <xdc/runtime/Diags.h>
#include <xdc/runtime/System.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>

/* TI-RTOS Header files */
#include <ti/drivers/I2C.h>
#include <ti/drivers/Board.h>

/* Board */
#include "ti_drivers_config.h"

/* MPU Driver Header */
#include "lib/MPU_DMP_C.h"
#include "lib/util/inv_mpu.h"
#include "lib/util/inv_mpu_dmp_motion_driver.h"

/* Extern declaration for the I2C handle used by the HAL */
extern I2C_Handle i2c_handle;

/*
 * ======== mpuTaskFxn ========
 * Task to initialize and read data from the MPU-6500.
 */
void mpuTaskFxn(UArg arg0, UArg arg1) {
    /* 1. Initialize I2C Driver and set the global handle */
    I2C_Params i2cParams;
    I2C_Params_init(&i2cParams);
    i2cParams.bitRate = I2C_400kHz;
    i2c_handle = I2C_open(Board_I2C0, &i2cParams);

    if (i2c_handle == NULL) {
        System_printf("Error Initializing I2C\n");
        System_flush();
        while (1);
    }

    /* 2. Create the MPU_DMP instance */
    MPU_DMP_Handle mpu_handle = MPU_DMP_Create();
    if (!mpu_handle) {
        System_printf("Failed to create MPU_DMP handle.\n");
        System_flush();
        while (1);
    }

    /* 3. Initialize the sensor */
    if (MPU_DMP_begin(mpu_handle) != INV_SUCCESS) {
        System_printf("Failed to initialize MPU sensor.\n");
        System_flush();
        while (1);
    }
    System_printf("MPU initialized.\n");
    System_flush();

    /* 4. Initialize the DMP with 6-axis quaternion feature at 100Hz */
    unsigned short dmp_features = DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_RAW_GYRO | DMP_FEATURE_GYRO_CAL;
    if (MPU_DMP_dmpBegin(mpu_handle, dmp_features, 100) != INV_SUCCESS) {
        System_printf("Failed to start DMP.\n");
        System_flush();
        while (1);
    }
    System_printf("DMP started. Reading data...\n");
    System_flush();

    /* 5. Main loop to read and process data */
    while (1) {
        // Try to read a new packet from the FIFO
        if (MPU_DMP_dmpUpdateFifo(mpu_handle) == INV_SUCCESS) {
            // New data is available, compute Euler angles in degrees
            MPU_DMP_computeEulerAngles(mpu_handle, true);

            // Get the calculated angles using accessor functions
            float yaw = MPU_DMP_get_yaw(mpu_handle);
            float pitch = MPU_DMP_get_pitch(mpu_handle);
            float roll = MPU_DMP_get_roll(mpu_handle);

            System_printf("Yaw: %.2f, Pitch: %.2f, Roll: %.2f\n", yaw, pitch, roll);
            System_flush();
        }

        // Let other tasks run. Sleep for 10ms.
        // Task_sleep() takes system ticks as an argument.
        Task_sleep(10 * 1000 / Clock_tickPeriod);
    }
}
```

> Whenever you use either of DMP versions, make sure to have the file `dmp_hal_stubs.c` in the same directory as the library, to avoid linker issues with unused functions, as well as the whole `util` directory.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

## Acknowledgements

The core DMP driver is based on the work by InvenSense/TDK.

The C++ wrapper is an adaptation of the excellent [SparkFun MPU-9250 DMP Arduino Library](https://github.com/sparkfun/SparkFun_MPU-9250-DMP_Arduino_Library).
